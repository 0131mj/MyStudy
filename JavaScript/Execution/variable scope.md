# 변수 스코프



## 변수 

변수란, 데이터를 담는 그릇이다. 이것을 컴퓨터의 언어로 말하면,  컴퓨터 메모리 주소의 alias를 말한다. 

변수는 다음과 같은 정보를 갖는다. 

- 메모리의 주소

- 데이터의 크기
- Scope : 변수의 유효 범위, 접근권한

- Life cycle : 변수는 영원히 존재하는 것이 아니라, 특정 시점에 태어났다가 사라진다. (거의 모든 computer language 는 life cycle 을 갖고 있다.)



## 변수variable 와 식별자 identifier

- 변수명은 다른 말로 식별자라고 부르기도 한다. 
- '변수' 가 아니라, '변수명' 이 식별자이다.



### 변수가 할당되는 원리

식별자를 위한 메모리 공간과 실제 값을 따로 할당하고, 식별자 공간에 변수메모리 주소를 할당시켜준다. 

```javascript
var a = 'xyz';
```

1. var a  변수가 어느 메모리(1001)에 선언된다. 
2. xyz 라는 텍스트가 다른 어느 메모리(9200)에 선언된다. 
3. var a의 메모리에(1001), 매핑된 값의 메모리주소(9200) 가 저장된다. 



### 변수가 변경되는 원리

변수를 그대로 두고, 새로운 값을 생성하여 매핑된 메모리 주소를 바꾼다. 

```javascript
a = 'pqr';
```

1. 'pqr' 이라는 텍스트가 어느 메모리(6330)에 선언된다.
2. a 에 매핑된 주소 (9200)이 6330 으로 변경된다. 



- 이렇게 일어나는 이유는 재할당이 빈번하게 일어나기 때문이다. 
- 재할당이 일어나면 



## 자바스크립트에서의 Scope

자바스크립트에서의  변수 스코프는 Life cycle 과 Scope 를 동시에 포괄하는 개념이다. 

자바스크립트의 변수 스코프를 이해하기 위해서는 자바스크립트가 실행되는 과정에 대해서 알아볼 필요가 있는데, 출처마다 조금씩 설명이 다르다. 



## 객체지향 자바스크립트



자바스크립트는 아래의 순서대로 실행된다. 

1. 파싱 Parsing
2. 변수, 함수 정의
3. 실행
   1. 함수코드 파싱
   2. 호출




### 1. 파싱 Parsing

우선 전역레벨의 파싱이 먼저 일어난다. 

파싱은 변수와 함수변수를 초기화하는 과정이다.

전역레벨 -> 함수레벨



### 2. 변수, 함수 정의 



---



## You don't know JS - 카일 심슨




## 컴파일

자바스크립트가 컴파일의 과정이 없다고 생각하기 쉬운데, 자바스크립트에는 아주 짧은 컴파일 과정이 존재한다. 

단지 '미리' 컴파일을 해놓지 않고 코드가 실행되기 바로 직전에 컴파일이 실행된다. 



자바스크립트의 컴파일은 3가지 단계로 진행된다.

1. 토크나이징/렉싱 : 문자열을 쪼갬
2. 파싱 : 쪼갠 문자열을 AST 형태로 변환
3. 코드 생성 : AST를 실행코드로 변환

---



### 1. 토크나이징

​	문자열을 쪼개는 것을 lexing 이라고도 한다. 



### 2. 파싱 Parsing AST 

```javascript
var a = 2;
```

이걸 실행했을때, AST가 어떻게 그려지는가는 아래 사이트를 보면 된다.

https://resources.jointjs.com/demos/javascript-ast

http://int3.github.io/metajs/

http://www.pythontutor.com/visualize.html#mode=edit



### 3. 코드 생성 



---



## 내가 정리한 결론



### 자바스크립트 실행과정 : 선 컴파일, 후 실행

자바스크립트는 실행되기 바로 직전에 컴파일을 먼저 하는데, 적절할 지는 모르겠지만 아래와 같이 비유를 해볼 수 있다. 

- 컴파일 : 접시를 준비하는 것(셋팅)

- 실행 : 접시위에 음식을 옮겨담는 것

순서상으로 볼 때, 자바스크립트 엔진은 컴파일을 다 하고 나서 실행을 한다. 즉, 접시 하나를 준비해서 음식을 담고, 또 다음 접시를 하나 더 꺼내서 다음 음식을 담는 방식이 아니라, 처음부터 접시를 다 깔아놓은 다음(컴파일)에 음식을 올린다(실행)는 말이다. 



#### 1. 선 컴파일 : 키워드를 만나면 정의를 한다.

그렇다면 자바스크립트는 어떻게 컴파일이 되는가? 변수 var test와 함수 function func에는 한가지 공통점이 있는데 식별자 앞에 var와 func 같은 키워드가 붙어있는 것이다. 이 var와 func의 역할은 '내가 변수요', '내가 함수요'라고 알려주기 위한 것으로,  컴파일 과정에서는 키워드를 만났을 때 이 키워드를 참고로 변수 및 함수를 정의한다.   

var 변수의 값은 undefined로 초기화된다. 

그러니까 var a, function func라는 두 개의 접시를 미리 준비하는 것이다.

| keyword  | identifier |
| -------- | ---------- |
| var      | a          |
| function | test       |

- var 없이 변수를 선언하면 컴파일 단계가 아니라, 실행 단계(런타임)에 전역변수 스코프가 정의된다. 




#### 2. 후 실행



#####  정리

1. 프로그램은 실행 전에 컴파일을 한다. 
2. 컴파일 이후에 실행된다.
3. 키워드들은 초기화되어버린다.

---





## 변수 스코프

변수 스코프 자체는 추상적인 개념이 아니라 하나의 객체이다. 

변수 스코프는 아래와 같은 구성으로 되어 있다. 



### 자바스크립트 스코프 객체의 구성

- arguments : 실제 호출에 사용되는 인수
- parameter : 함수에서 정의하는 매개변수
- 내부 변수




```javascript
function add(x, y){
    var a = x + y;
    return a;
}

add(1,2,3);
```

- "arguments" : [1, 2, 3]
- "x" : 1
- "y" : 2
- "a" : undefined;





## 자바스크립트 스코프의 특징

자바스크립트의 변수스코프는 3가지 특징을 갖고 있다. 

1. 함수 단위의 변수관리

2. 실행시의 변수 검색은 렉시컬 영역을 기준으로 한다. 

3. 실행시의 변수 검색은 변수 스코프체인을 이용한다. 

   


#### 1. 함수단위 스코프

```javascript
function add(x,y){
    this.a = x;
    this.b = y;
    this.c = 'c';
    var d = 'd';
    e = 'e'
    return a + b;
}

add.m = 'm';
console.log(add(3,5)); //8
console.log(add.a); //undefined
console.log(add.c); //undefined
console.log(add.d); //undefined
console.log(add.e); //undefined
console.log(e); //e
console.log(add.m); //m
```

- 기본적으로 자바스크립트는 함수 단위로 스코프가 정해진다. 
- 자바스크립트 함수 내부에 정의된 변수는 지역변수로서, 외부에서 접근이 불가능하다. 
- 단, 유동적으로 추가한 변수(m)의 경우 외부에서 접근이 가능한데 이것은 변수가 다른 스코프에 저장이 되기 때문이다. 
- var를 빼고 선언한 변수는 글로벌 스코프를 가진다. (하지만 add.e와 같이 함수내부 형태로의 접근은 안된다.)





#### 2. let, const의 스코프

```javascript
function double(x){
    if(x !== null){
        var result = x * 2;
        console.log(result); 
    }
    console.log('result is ' + result);
}
double(3);  //6, result is 6
```

double() 함수를 보면 result라는 변수는 if문 안에 있다. 하지만 result는 if문 바깥에서도 호출이 가능한데, 
그 이유는 <u>'함수 안에 작성된 변수의 범위는 그 함수 범위 전체'</u> 이기 때문이다.  



```javascript
function double2(x){
    if(x !== null){
        const result = x * 2;
        console.log(result); 
    }
    console.log('result is ' + result);
}
double2(3); //6, Uncaught ReferenceError : result is not defined
```

double2()의 경우 결과가 다르게 나타는데 result앞에 var대신 <u>let이나 const를 사용할 경우, 변수의 스코프는 해당 블록까지</u>만이다. 따라서 if문 밖을 벗어나서 result를 호출하면 에러를 출력한다. 




#### 3. 렉시컬 스코프

스코프는 설정하는 방식에 따라 두가지 방식으로 나눌 수 있다.

- 렉시컬 스코프 : 실행환경이 아닌 '정의'환경으로 함수의 스코프 설정
- 다이나믹 스코프 : '실행'환경으로 스코프 설정

자바스크립트는 렉시컬 특성으로 스코프를 설정한다. eval, with 같은 방법으로 렉시컬 스코프를 수정할 수는 있지만, 위험해서 다들 쓰지 말라고 그러니까 몰라도 된다. 



##### 렉시컬 스코프와 렉싱의 관계

프로그램이 로드되면 아래의 두 절차에 따라 준비가 된다. 

- 변수 선언 : 컴파일러가 담당
- 데이터 할당 : 엔진이 담당

변수 선언을 할 때 우선 모든 단어를 쪼개는 데 이것을 렉싱이라고 부른다. 

하지만 렉싱타임에 렉시컬 스코프가 결정된다고 하기는 어려울 것 같다. 

왜냐하면, 단어를 단순히 쪼개는 것 만으로는 해당 변수가 어디에 놓일지 알 수 없기 때문이다. 



### var 있고 없고의 차이



#### 있을 때

```javascript
var a = 'global'
function test(){
  alert(a); //undefined
  var a = 'local';
  alert(a); //local
}
test();
```

우선 생각해보면 test();를 실행했을 때 첫번째 alert()에서는 undefined가 아니라 global이 나올거 같다.  하지만 이게 생각대로 되지 않는 이유는 test 코드블럭이 다음과 같은 순서로 실행이 되기 때문이다. 

1. test 함수의 컴파일 단계 : 자바스크립트 엔진이 코드를 한줄씩 읽어나가는데 실행문은 건너뛰고 우선 var가 나오면 초기화부터 하고 본다. 코드 블럭 내부의 3줄 중에서 var가 붙은 a를 보고 초기화작업을 준비한다. 전역레벨에 동일한 이름의 a가 있긴 하지만 var 붙여주면 '이 구역의 변수는 나야' 라고 영역 표시 선언을 하는 셈이 된다.  따라서 함수 안에서 선언된 var a는 바깥에 선언된 동일한 이름의 var a와는 독립된 변수가 된다. 이 과정을 거치고 나면 함수 내부에서 var a는 undefined로 초기화가 되었을 것이다. 
2. test 함수의 첫번째 줄 : alert(a);를 하면, 초기화된 a가 undefined이기 때문에 undefined를 출력한다. 
3. test 함수의 두번째 줄 : 그 뒤에 함수코드블럭의 두번째 줄에서 a에 'local'을 할당한다.  
4. test 함수의 세번째 줄 : 이제 alert(a);는 local을 출력한다.



#### 없을 때

```javascript
var a = 'global'
function test(){
  alert(a); //global
  a = 'local';
  alert(a); //local
}
test();
```

1. test 함수의 컴파일 단계 : 여기서는 두번째 줄 a에 var 키워드가 붙어있지 않다. 이 말은 뭐냐면, 선언된 게 없으므로 컴파일러가 지나친다는 것이다. a에 local을 할당하는 것은 나중의 일이다. 
2. test 함수의 첫번째 줄 : alert(a);는 선언된 a를 찾지 못하고 상위레벨인 전역레벨에서 a를 찾는다. 따라서 global을 출력한다. 
3. test 함수의 두번째 줄 : 이제 변수 a에 local이 할당되는데, 변수에 a를 붙이지 않으면 전역레벨의 변수가 된다. 그런데 전역의 a에는 global이 들어 있다. 이때 a는 global을 대체하고 local로 값을 바꿔버린다. 
4. test 함수의 네번째 줄 : a를 출력하면 local이 된다. 주의해야 할 점은, a가 전역레벨에 있는 a라는 점이다. 



정리해보면 이렇다. var를 붙여준다는 것은 '이 변수의 스코프를 지금 있는 함수 안으로 한정하겠다'라는 선언이고, 이 선언을 하게되면 바깥레벨에 있는 동일한 이름의 변수와는 독립된 변수가 된다. 





## 변수의 종류와 스코프

- 함수의 인자
- 함수 안에서 선언된 지역변수
- ES6 에서의 블록 스코프 변수
- 멤버변수 : 클래스의 인스턴스의 속성 (객체가 살아있을 때 까지 보존됨) - 라이프사이클이 길다.
- 자유변수 : 함수 혹은 인스턴스 메소드의 입장에서, 자기가 원래 알수 없는 권한의 변수 
  - 함수가 원래 알 수 있는 것은 원래 지역변수와 인자 밖에 없다.  이를  제외한 모든 변수는 자유변수이다. 
  - 클래스의 메소드가 원래 알 수 있는 것은, this로 부터 시작하는 멤버변수, 지역변수, 인자이고, 이를 제외한 모든 변수는 자유변수이다.
  - Closure : 특정 자유변수가 사용가능한 공간



### 클로저와 변수 스코프

```javascript
if(false){
	let a = 3;   
}

let b = 4;
const f = () => {
    console.log(b);
}
```

- 함수 f 의 입장에서, 멤버변수도 아니고 인자도 아닌 a 와 b 는 둘 다 자유변수이다. 
- f의 { }는, b가 사용될 수 있는 공간이다. 
- 이걸 다른 말로 표현하면, 함수 f의 { } 는, b 의 클로저가 된다. 
- 다시 말해, 자유변수 b의 클로저는 f 함수이다. 



## Shadowing

- 자유변수의 우선순위가 낮다. 