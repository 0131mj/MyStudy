# 스코프 scope



#### Identifier Resolution : 식별자 결정

스코프의 목적은 식별자의 값을 찾는 데 있다. 

스코프를 갖고 내부 =>  외부 =>  전역을 뻗어나가면서 식별자의 값을 탐색한다. 

만약 내부에 'name' 이라는 프로퍼티의 값이 있다면 더이상 식별자의 값을 찾지 않지만 찾지 못하면 함수 외부에서 찾게 된다. 

스코프가 존재하기 때문에 문법을 간략하게 사용할 수 있다. 

중요한 것은 식별자를 해결하는 것이며,

스코프는 그 자체가 목적이라기 보다는 식별자를 해결하기 위한 수단에 불과하다고 봐야 한다.



#### 식별자 해결을 위한 수단

##### ES 3 

함수가 "호출" 되면 scope를 생성하고  {name: value} 와 같은 객체 형태로 만들어낸다. 

이렇게 식별자를 검색하기 위한 리스트를 scope chain 이라고 부른다. 

함수가 생성될 때마다 동적으로 별도의 구조체인 scope chain 에 스코프를 연결한다.

- 다이나믹 스코프 사용
- 스코프 체인 scope Chain
- 활성객체 Activation Object : 함수의 실행결과, 환경



##### ES 5 

함수가 "선언" 되면 렉시컬 환경 컴포넌트를 만든다.

- 정적 스코프 사용
- Lexical Environment: 기존 Activaion Object를 대체 한다.



##### scope chain 이라는 용어에 대해...

스코프의 목적은 식별자를 해결하기 위한 것이고, 
내부 => 외부 => 전역으로 뻗어나가면서 식별자를 탐색하고 결정한다.
 이러한 논리적인 선형목록을 ECMAScript3이전에는 명세상에서  'scope chain'이라고 칭했다. 

EcmaScript5 이후로는 렉시컬환경을 기반으로 식별자를 결정한다. 
기존 scope chain는 Lexical Environment의 Declarative Environment Recode 에서 식별자를 검색한다. 
그리고 내부 탐색만으로 식별자 해결이 되지 않을 때,  외부렉시컬환경에서 변수를 탐색한다. 
따라서 이러한 탐색과정을 ECMAScript5 이후부터 (관점에 따라 이것도 체이닝으로 볼 수는 있겠지만 공식적으로는)
"체인"이라는 용어로 부르지 않는 것이다. 

모던 자바스크립트 입문(길벗, 286p) 에서는 이 단어 대신 '유효범위 체인' 이라는 이름로 대체해서 설명하고 있다.



## 1. 변수 

변수란, 데이터를 담는 그릇이다. 이것을 컴퓨터의 언어로 말하면,  컴퓨터 메모리 주소의 alias를 말한다. 

변수는 다음과 같은 정보를 갖는다. 

- 메모리의 주소

- 데이터의 크기
- Scope : 변수의 유효 범위, 접근권한

- Life cycle : 변수는 영원히 존재하는 것이 아니라, 특정 시점에 태어났다가 사라진다. (거의 모든 computer language 는 life cycle 을 갖고 있다.)



### 변수의 종류와 스코프

- 함수의 인자
- 함수 안에서 선언된 지역변수
- ES6 에서의 블록 스코프 변수
- 멤버변수 : 클래스의 인스턴스의 속성 (객체가 살아있을 때 까지 보존됨) - 라이프사이클이 길다.
- 자유변수 : 함수 혹은 인스턴스 메소드의 입장에서, 자기가 원래 알수 없는 권한의 변수 
  - 함수가 원래 알 수 있는 것은 원래 지역변수와 인자 밖에 없다.  이를  제외한 모든 변수는 자유변수이다. 
  - 클래스의 메소드가 원래 알 수 있는 것은, this로 부터 시작하는 멤버변수, 지역변수, 인자이고, 이를 제외한 모든 변수는 자유변수이다.
  - Closure : 특정 자유변수가 사용가능한 공간



#### 클로저와 변수 스코프

```javascript
if(false){
	let a = 3;   
}

let b = 4;
const f = () => {
    console.log(b);
}
```

- 함수 f 의 입장에서, 멤버변수도 아니고 인자도 아닌 a 와 b 는 둘 다 자유변수이다. 
- f의 { }는, b가 사용될 수 있는 공간이다. 
- 이걸 다른 말로 표현하면, 함수 f의 { } 는, b 의 클로저가 된다. 
- 다시 말해, 자유변수 b의 클로저는 f 함수이다. 



#### Shadowing

- 자유변수의 우선순위가 낮다. 





## 2. 자바스크립트 변수 스코프 객체의 구성

변수 스코프 자체는 추상적인 개념이 아니라 하나의 객체이다. 

변수 스코프는 아래와 같은 구성으로 되어 있다. 

- arguments : 실제 호출에 사용되는 인수
- parameter : 함수에서 정의하는 매개변수
- 내부 변수


```javascript
function add(x, y){
    var a = x + y;
    return a;
}

add(1,2,3);
```

- "arguments" : [1, 2, 3]
- "x" : 1
- "y" : 2
- "a" : undefined;





## 3. 자바스크립트 스코프의 특징

자바스크립트의 변수스코프는 3가지 특징을 갖고 있다. 

1. 함수 단위의 변수관리

2. 실행시의 변수 검색은 렉시컬 영역을 기준으로 한다. 

3. 실행시의 변수 검색은 변수 스코프체인을 이용한다. 

   


#### 1. 함수단위 스코프

```javascript
function add(x,y){
    this.a = x;
    this.b = y;
    this.c = 'c';
    var d = 'd';
    e = 'e'
    return a + b;
}

add.m = 'm';
console.log(add(3,5)); //8
console.log(add.a); //undefined
console.log(add.c); //undefined
console.log(add.d); //undefined
console.log(add.e); //undefined
console.log(e); //e
console.log(add.m); //m
```

- 기본적으로 자바스크립트는 함수 단위로 스코프가 정해진다. 
- 자바스크립트 함수 내부에 정의된 변수는 지역변수로서, 외부에서 접근이 불가능하다. 
- 단, 유동적으로 추가한 변수(m)의 경우 외부에서 접근이 가능한데 이것은 변수가 다른 스코프에 저장이 되기 때문이다. 
- var를 빼고 선언한 변수는 글로벌 스코프를 가진다. (하지만 add.e와 같이 함수내부 형태로의 접근은 안된다.)





#### 2. let, const의 스코프

```javascript
function double(x){
    if(x !== null){
        var result = x * 2;
        console.log(result); 
    }
    console.log('result is ' + result);
}
double(3);  //6, result is 6
```

double() 함수를 보면 result라는 변수는 if문 안에 있다. 하지만 result는 if문 바깥에서도 호출이 가능한데, 
그 이유는 <u>'함수 안에 작성된 변수의 범위는 그 함수 범위 전체'</u> 이기 때문이다.  



```javascript
function double2(x){
    if(x !== null){
        const result = x * 2;
        console.log(result); 
    }
    console.log('result is ' + result);
}
double2(3); //6, Uncaught ReferenceError : result is not defined
```

double2()의 경우 결과가 다르게 나타는데 result앞에 var대신 <u>let이나 const를 사용할 경우, 변수의 스코프는 해당 블록까지</u>만이다. 따라서 if문 밖을 벗어나서 result를 호출하면 에러를 출력한다. 




#### 3. 렉시컬 스코프

스코프는 설정하는 방식에 따라 두가지 방식으로 나눌 수 있다.

- 렉시컬 스코프 : 실행환경이 아닌 '정의'환경으로 함수의 스코프 설정
- 다이나믹 스코프 : '실행'환경으로 스코프 설정

자바스크립트는 렉시컬 특성으로 스코프를 설정한다. 

eval, with 같은 방법으로 렉시컬 스코프를 수정할 수는 있지만, 위험해서 다들 쓰지 말라고 그러니까 몰라도 된다. 



##### 렉시컬 스코프와 렉싱의 관계

프로그램이 로드되면 아래의 두 절차에 따라 준비가 된다. 

- 변수 선언 : 컴파일러가 담당
- 데이터 할당 : 엔진이 담당

변수 선언을 할 때 우선 모든 단어를 쪼개는 데 이것을 렉싱이라고 부른다. 

렉싱타임에는 어휘를 단순히 쪼개는 것 뿐만 아니라, 생셩된 토큰에 의미를 부여한다. 

따라서 이것을 렉시컬 스코프라고 부를 수 있다. 



this는 약간 다르게 동작한다.



### var 있고 없고의 차이



#### 있을 때

```javascript
var a = 'global'
function test(){
  alert(a); //undefined
  var a = 'local';
  alert(a); //local
}
test();
```

우선 생각해보면 test();를 실행했을 때 첫번째 alert()에서는 undefined가 아니라 global이 나올거 같다.  하지만 이게 생각대로 되지 않는 이유는 test 코드블럭이 다음과 같은 순서로 실행이 되기 때문이다. 

1. test 함수의 컴파일 단계 : 자바스크립트 엔진이 코드를 한줄씩 읽어나가는데 실행문은 건너뛰고 우선 var가 나오면 초기화부터 하고 본다. 코드 블럭 내부의 3줄 중에서 var가 붙은 a를 보고 초기화작업을 준비한다. 전역레벨에 동일한 이름의 a가 있긴 하지만 var 붙여주면 '이 구역의 변수는 나야' 라고 영역 표시 선언을 하는 셈이 된다.  따라서 함수 안에서 선언된 var a는 바깥에 선언된 동일한 이름의 var a와는 독립된 변수가 된다. 이 과정을 거치고 나면 함수 내부에서 var a는 undefined로 초기화가 되었을 것이다. 
2. test 함수의 첫번째 줄 : alert(a);를 하면, 초기화된 a가 undefined이기 때문에 undefined를 출력한다. 
3. test 함수의 두번째 줄 : 그 뒤에 함수코드블럭의 두번째 줄에서 a에 'local'을 할당한다.  
4. test 함수의 세번째 줄 : 이제 alert(a);는 local을 출력한다.



#### 없을 때

```javascript
var a = 'global'
function test(){
  alert(a); //global
  a = 'local';
  alert(a); //local
}
test();
```

1. test 함수의 컴파일 단계 : 여기서는 두번째 줄 a에 var 키워드가 붙어있지 않다. 이 말은 뭐냐면, 선언된 게 없으므로 컴파일러가 지나친다는 것이다. a에 local을 할당하는 것은 나중의 일이다. 
2. test 함수의 첫번째 줄 : alert(a);는 선언된 a를 찾지 못하고 상위레벨인 전역레벨에서 a를 찾는다. 따라서 global을 출력한다. 
3. test 함수의 두번째 줄 : 이제 변수 a에 local이 할당되는데, 변수에 a를 붙이지 않으면 전역레벨의 변수가 된다. 그런데 전역의 a에는 global이 들어 있다. 이때 a는 global을 대체하고 local로 값을 바꿔버린다. 
4. test 함수의 네번째 줄 : a를 출력하면 local이 된다. 주의해야 할 점은, a가 전역레벨에 있는 a라는 점이다. 



정리해보면 이렇다. var를 붙여준다는 것은 '이 변수의 스코프를 지금 있는 함수 안으로 한정하겠다'라는 선언이고, 이 선언을 하게되면 바깥레벨에 있는 동일한 이름의 변수와는 독립된 변수가 된다. 





## 4. 스코프  vs 라이프사이클

자바스크립트에서의  변수 스코프는 Life cycle 과 Scope 를 동시에 포괄해서 칭한다. 하지만 변수의 라이프사이클과 스코프는 다른 개념이다. 

메모리와 연산은 교환될 수 있다. 즉, 연산을 많이 하면 메모리를 아낄 수 있고, 메모리를 많이 쓰면 연산을 줄일 수 있다. 



#### 라이프사이클

- 메모리의 정의
- 정의 : 변수가 얼마나 오래 생존하는가.
- 규칙 : 최대한 짧게 유지하고, 빨리 죽인다.



#### 스코프

- 권한에 관련된 문제
- 정의 : 그 변수를 어디에서 읽어들일 수 있는가.
- 규칙 : 되도록이면 좁게 짠다. 



##### 라이프사이클을 길게 유지한 케이스 (연산 성능 중시)

```javascript
const f =(() => {
    const innerF = () {}
    return innerF;
})();
```

이렇게 IIFE 로 짜놓으면 innerF는 f가 살아있는 동안 계속 유지된다. 스코프는 f만 알수 있으며,  라이프사이클은 길다.



##### 라이프사이클을 짧게 유지한 케이스 (메모리 효율성 중시)

```javascript
const f = data => {
    const innerF =(){}
    return innerF(data);
}
```

위와 스코프는 같지만, 라이프사이클은 짧은 케이스



## 5. 다이나믹 스코프

실행 시점에 스코프를 결정하는 케이스는 두 가지가 있다. 

- with 문
- eval 문