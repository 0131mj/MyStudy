# this



#### this의 존재 이유

this는 자바스크립트에서 가장 난해한 개념 중의 하나이다. 딱 봐서는 바로 알 수 없기 때문이다.

그럼 왜 이런게 존재하는 걸까?



this는 자바스크립트의 키워드 중에서 유일한 지시대명사이다. 

코드를 떠나, 지시대명사 자체의 유용함에 대해 생각해보자. 

지시대명사는 대상의 이름을 직접 언급하지 않음으로서 얻는 유연함과 편리함이라는 이득이 있다. 

('나'라는 지시대명사가 없었다면 모든 사람들은 어린아이가 이야기 하듯 자신의 이름을 부르며 지칭했을 것이다.)



코드의 입장에서 보자면, 써놓은 코드가 맥락, 상황에 따라 다른 것을 가리키는 유연성이 있다. 

다시 말해 이 this라는 지시대명사 키워드는 일일이 이름을 부르지 않고 '자신이 수행될 컨텍스트'를 가리킨다는 점에서 유용하며, 

컨텍스트가 달라지면 코드의 수행없이 해당 컨텍스트를 가리키게 되므로 유연하다고 볼 수 있다.



#### this 라는 뉘앙스의 난해함

왜 하필 that, it 도 아니고 this 일까?

여기서 this란 자기 자신을 뜻한다.

(영어에서는, 전화를 걸어서 알수 없는 상대방에게 자신을 이야기 할때, "I am Tom" 이라고 하지 않고 "This is Tom" 이라고 한다. )

'이것' 이라는 해석보다는 코드가 처한 입장에서 자기 자신의 맥락을 지칭한다고 봐야 할 것이다.





## this의 비결정성

this가 어려운 이유는, 쓰임새에 따라 가리키는 대상이 달라지기 때문이다. 

> this는 작성시점이 아닌, 런타임 시점에 바인딩 되며, 함수 호출 상황에 따라 컨텍스트가 결정된다. 
>
> - You Don't Know JS



즉, this 는 선언이 아니라 호출에 의해 결정된다.

1. this는 실행컨텍스트가 생성될 때 thisBinding에서 결정된다. 
2. 실행 컨텍스트는 함수 호출시에 결정된다. 
3. 따라서 this는 함수 호출시 결정된다.





## this 바인딩 case by case

일단 결론부터 말하자면 다음과 같다.

- case 1. 객체의 메서드를 호출할 때 : this는 자신을 호출한 객체로 바인딩 된다. 
- case 2. 전역객체의 함수를 호출할 때 : 전역 객체에 바인딩 (use strict 선언이 있을경우 전역바인딩에서 제외)
- case 3. 생성자 함수를 호출할 때 : 새롭게 생성되는 빈 객체에 바인딩 
- case 4. call과 apply 사용시 : 지정해준대로 바인딩 (첫번째 인자)



case 1 과  case 2의 차이점은 별로 없다. 

왜냐하면, case 2는 암묵적으로 global 객체에 바인딩되어 있기 때문에,

결국 객체의 메서드를 호출한 것이나 마찬가지다. 

```javascript
const obj = {
    num: 1,
    f: function(){
        console.log("num: ", this.num); // (0)
    }
}
obj.f(); // (1) num : 1 
const f = obj.f;
f(); // (2) num : undefined
f.call(obj);// (3) num: 1
```



(2) 에서 전개를 한 f 함수의 결과는 undefined로 나온다. 

만일  (0) 에서 this.num 대신 obj.num이라고 해주면 렉시컬에 의해 1을 출력한다.

하지만, obj.num을 쓰는 것은 권장할만한 사항이 아니다. 

obj 에는 객체가 아니라 주소값만 담아놓은 것이기 때문에 obj에서 참조할 주소가 사라졌을때 객체 스스로를 조회할 수 없는 에러가 발생할 수 있다. 



헷갈리는 것은 내부 함수 호출할 때다. 

내부함수에서 호출한 녀석을 따로 지정해주지 않았다면, 내부함수 innerFunc()의 this 또한 전역 객체에 바인딩 된다. 

(하지만 그렇다고해서 글로벌 함수로 정의되었다라는 말이 아니라, this의 바인딩만 그렇게 되었다는 것이다.)



## this 란, this 를 호출한 대상을 가리킨다. 

- 자바스크립트에서 this는 호출된 시점에 결정되므로,  this 가 가리키는 것은 늘 달라진다. 
- 하지만, 예외가 있다. 바로 bind 



## bind()

- this가 되게 할 대상을 func.bind(that) 이런식으로 묶으면 func의 this 는 항상 that을 가리키게 된다. 



---

https://ui.dev/this-keyword-call-apply-bind-javascript/



