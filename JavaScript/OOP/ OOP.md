# 객체지향 자바스크립트



## 1. 추상화 기법

객체지향 프로그램의 출발점은 추상화이다. 

이는 아래의 3가지 개념을 토대로 이루어진다. 



#### 1) Categorizing : 범주화

ex) 여자/남자, 성인/미성년자, 

1. 병렬적 카테고리
2. 직렬적 카테고리



#### 2) Modeling : 대상화

꼭 기억해야만 할 정보만 빼서 다루는 것.

ex) 학생이면 학번과 이름만 있으면 된다. 



#### 3) Grouping: 집합

1. 팀과 그룹으로 나눈 것.



## 2. 객체지향 시스템의 요건

- 최소한 아래 2가지의 요소를 만족하면 객체지향 시스템으로 간주한다. 



#### 1)대체 가능성

- 구상형은 추상형으로 대체가능하다. 
- 자식이 부모를, 구상클래스가 추상클래스를 대신할 수 있다. 

- 상속, 위임 등이 가능하게 하는 근거



#### 2) 내적 동질성

- 구상이 추상보다, 자식이 부모보다 자식이 우선한다. 
- override가 가능한 근거



## 3. 객체지향의 기본 전략

- 아래 2가지의 사항이 기본적인 객체지향의 방향성이다. 
- 반드시 지키지는 않아도 되나, 권장하는 사항이다. (매너)
- 부모클래스와 자식클래스간의 관계에서도 적용된다.



#### 1) 은닉

- 내부가 어떻게 생겨먹었는지 아무것도 안보여주는 것이 좋다.



#### 2) 캡슐화 

- ex) ATM기
- 자세히 아는게 독이 된다.
- 상대방이 몰라도 되는 이상 상세하게 알려주지 않고, 추상화된 정보만 알려준다. 



## 4. 객체의 특성

- 캡슐화 : ATM에서 돈을 인출할때, 내부로직을 몰라도 외부에서 요청한대로 처리 가능
  - cf : 은닉화 : 숨기기 (보여주지 않게 한다. )
- 다형성
  - 내적 일반성
  - 대체 가능성



## 5. 프로토콜

- 규정, 협약, 의정서 약정서 합의서
- 최소한의 알고싶은 정보만 보내고싶을 때의 
- 1900년대 초기의 컨테이너의 발명



#### * 프로토콜의 적용기준 : 변화율

- Math.sign 과 같은 함수는 절대 변하지 않는다.
- 변화율이 다르다면, 로직이 다르다면 프로토콜이 필요



## 6. 컨텍스트

- 인스턴스 마다 고유하게 부여되는 메모리
- 함수와 다른점
  - 함수 : 인자 or 지역변수 (또는 자유변수) 이용
  - 객체지향 : 컨텍스트변수 이용



#### * 함수형 프로그래밍 vs 객체지향 프로그래밍

##### 상태유지의 방법

- 함수형 프로그래밍 : 자유변수를 통해 유지(새롭게 함수를 생성하는 전략)
- 객체지향 프로그래밍 : 컨텍스트를 이용



### 위임

- 클래스의 입장에서, "이게 내가 할 일이 아니다" 싶으면 바깥쪽으로 위임을 한다.



#### * 위임방법 1. 임시적인 바인딩

- 관계가 약한 관계라면, 함수 호출시점에 불러서 쓴다. 

```javascript
const Apple = class {
    constructor(){
        this.magicNumber = 1;
    }
    makeDouble = (n) => {
        return n*2 + this.magicNumber;
    }
}

const apple = new Apple()

const Banana = class {
    outFuncRequest = (apple) => {
        const result = apple.makeDouble(2);
    }
}
```



#### * 컨텍스트를 통한 상태유지 방법

- 관계가 강할 경우, 외부와 직접바인딩을 하지 않고, 생성자에서, 클래스 내부의 컨텍스트변수에 할당을 한다. 

```javascript
const Apple = class {
    constructor(){
        this.magicNumber = 1;
    }
    makeDouble = (n) => {
        return n*2 + this.magicNumber;
    }
}

const apple = new Apple()

const Banana = class {
    constructor(a){
        this.a = a;
    }
    outFuncRequest = () => {
        const result = this.a.makeDouble(2);
    }
}

const bananna = new Banana(b)
```



