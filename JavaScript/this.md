# this

this가 어려운 이유는, 쓰임새에 따라 가리키는 대상이 달라지기 때문이다. 

> this는 작성시점이 아닌, 런타임 시점에 바인딩 되며, 함수 호출 상황에 따라 컨텍스트가 결정된다. - You Don't Know JS



## this 바인딩 case by case

일단 결론부터 말하자면 다음과 같다. (급하면 이해하기 전에 암기부터 하자.)

- case 1. 객체의 메서드를 호출할 때 : this는 자신을 호출한 객체로 바인딩 된다. 
- case 2. (전역객체의) 함수를 호출할 때 : 전역 객체에 바인딩
- case 3. 생성자 함수를 호출할 때 : 새롭게 생성되는 빈 객체에 바인딩 
- case 4. call과 apply 사용시 : 지정해준대로 바인딩 (첫번째 인자)



case 1 과  case 2의 차이점은 별로 없다. 

왜냐하면, case 2는 암묵적으로 global 객체에 바인딩되어 있기 때문에,

결국 객체의 메서드를 호출한 것이나 마찬가지다. 



헷갈리는 것은 내부 함수 호출할 때다. 

내부함수에서 호출한 녀석을 따로 지정해주지 않았다면, 내부함수 innerFunc()의 this 또한 전역 객체에 바인딩 된다. 

(하지만 그렇다고해서 글로벌 함수로 정의되었다라는 말이 아니라, this의 바인딩만 그렇게 되었다는 것이다.)