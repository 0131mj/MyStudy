# 중첩된 for 문



```javascript
// A
for (let i = 0; i < 1; i++) {
    for (let j = 0; j < 10000; j++) {
    }
}

// B
for (let i = 0; i < 10000; i++) {
    for (let j = 0; j < 1; j++) {
    }
}
```

A 와 B 는 성능이 다를까?

다르다. 얼핏봐서는 (1 x 10,000 === 10,000 x 1) 이런 식으로 동일해 보인다. 

하지만, 안쪽 루프는 바깥쪽 루프의 업보를 고스란히 물려받는다. 

루프를 도는 횟수 자체가 다른 것이다.



#### A의 시나리오

- 바깥쪽 루프 : 1번만 돌아야지 (돌면서 자기 할일도 해야함)
- 안쪽 루프 : 내 할일을 하고 바깥쪽으로 스코프를 넘겨주자. (10,000번 반복: 내 할일 수행)
- 바깥쪽 루프: 안쪽 루프 실행이 끝났구나, 나는 1번만 도는거니까 이제 끝내면 되겠다.



#### B의 시나리오

- 바깥쪽 루프 : 10,000번 돌아야하는 구나... 일단 1번 돌아볼까? (돌면서 자기 할일도 해야함)
- 안쪽 루프 : 몇 회째지...? 음... 일단 내 할일을 하고 바깥쪽으로 스코프를 넘겨주자. (1번 반복: 내 할일 수행) => 이 일을10,000번 하겠지...
- 바깥쪽 루프 : 자, 이제 2번째구나, 다시 시작하자. ( x 10,000 회 반복)



내 생각에 A 와 B 가 같다고 착각을 하기 쉬운 이유는 두 가지이다. 

첫번째는 1과 10000이라는 산술적 상관관계만을 보고 단순하게 짐작해버린 것이고, 

두번째는 바깥쪽루프와 안쪽 루프문 사이에 아무런 코드가 없기때문에 단순히 반복의 횟수만 보고 판단하도록 (즉, 첫번째 추론의 확정화) 오해를 부른 것 같다. 





#### 검증하기

```javascript
const nestedLoop = (outer, inner) => {
    console.time();

    let outer_Cnt = 0;
    let inner_Cnt = 0;
    for (let i = 0; i < outer; i++) {
        outer_Cnt++;
        for (let j = 0; j < inner; j++) {
            inner_Cnt++;
        }
    }
    
    console.table({ outer_Cnt, inner_Cnt, TOTAL: outer_Cnt + inner_Cnt});
    console.timeEnd();
}
nestedLoop(2, 10000); // 0.48ms, TOTAL: 20,002
nestedLoop(10000, 2); // 1.89ms, TOTAL: 30,000
```

동일한 로직을 실현하기 위해 함수를 만들어 실행해본다. 

실행 시간을 측정하고, 루프를 돌때 카운트를 누적하여 출력한다.



여기서 테스트를 할 때, 숫자를 매우 작게 넣으면 (1,100 / 100, 1) 의외로 바깥쪽 카운트를 더 크게 잡을 때 시간이 더 적게 걸린다. 

아마도 엔진에서 뭔가를 처리하는 속도가 일정수준이하가 되면 선언하는 것이 처리하는 것보다 오히려 오래 걸린다던가 하는 그런 문제가 아닐까 싶다. 



참고자료

https://bytefish.medium.com/does-for-loop-nesting-order-affect-performance-dbc677217e66