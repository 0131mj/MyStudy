# Flow Control



## 코드 실행을 가장 단순한 형태로 생각해보기

C언어에서의 if 제어문을 어셈블리어로 변환되었을 때의 과정을 보자면 아래의 네가지 형태를 지속적으로 반복함을 알 수 있다. 

- 탐색
- 판단
- 수행
- 이동

현재위치를 파악하고, 주어진 조건을 판단한다. 판단에 맞다면 수행을 하고, 아니면 이동을 한다.



### Flow Control

- 명령이 실행되어 값이 적재되거나 변경되는 과정
- 의도적으로 if 혹은 for 등으로 분기와 반복을 수행할 수 있다. 



### SubFlow

- 서브루틴 : 여러번 재사용가능한 흐름
- 함수: 자신을 호출한 곳으로 되돌아 올 수 있다. 
- 호출시 복귀포인트를 지정해둔다.



### Sync Flow 

- 메모리에 적재된 명령이 순차적으로 실행됨
- SyncFlow Control : Goto를 통해 명령의 위치를 이동함





## 스택구조

- 스택은 메모리 구조중에 가장 속도가 빠르다. 실행할 것이 가장 위에 올라와있기 때문이다. 
- 서브루틴에서 서브루틴을 중첩으로 호출할 경우, 올라와 있는 것을 해제하는 스택 방식으로 움직인다. 



#### 스택 오버플로우

```javascript
const acc = v=> v ? v + acc(v - 1) : 0;
console.log(acc(100000)); // Uncaught RangeError: Maximum call stack size exceeded
```

이 함수는 1부터 주어진 숫자만큼 더하는 로직을, 재귀적인 방식으로 수행하는 함수이다. (1000 + 999 + 998 + .... + 1)

맨 안쪽에 있는 함수가 콜스택에서 날라가기 전에는 스택이 재귀를 해제하지 않기 때문에, 10만층의 콜스택이 쌓인다. 이때 브라우저가 뻗어버린다. 

브라우저는 메모리의 한계치에 도달해서 뻗는게 아니라, 컴퓨터의 성능과 상태를 고려해 어느 정도 콜스택에 도달하면 스스로가 판단해서 멈춘다. 

컴퓨터의 성능에 따라 Maximum call stack size 는 다르게 나타난다. 10만번이 될수도, 1만번이 될 수도 있는 것이다.



#### 꼬리재귀 최적화

위의 상황이 발생하지 않으려면, 한개의 스택이 종료되었을 때 리턴포인트를 다음 스택으로 위임해주면 된다. 

이를 꼬리재귀 최적화 tail recursive optimization 라고 하는데, 이건 언어차원에서 지원을 해줘야 한다. 



```javascript
const acc = v=> v ? v + acc(v - 1) : 0;
```

이 코드가 해제되지 않는 이유는, 돌아와서 할 일이 있기 때문이다. 즉, acc(v -1)을 하고 난 후에 돌아와서 다시 v를 더해야 한다. 

그래서 콜스택이 해제되지 않는 것이다.돌아와서 해야 할 일이 있다면, 돌아와서 할일을 인자값으로 넘겨줘버리면 된다. 



해결 : 

```javascript
const _sum = (v, acc)=> v > 1 ? _sum(v - 1, acc +v) : acc + 1;
const sum = num => (_sum(num, 0));
```

...이 안된다. 크롬 v8엔진은 꼬리물기 최적화를 지원하지 않는다. (2021년 현재 꼬리재귀 최적화를 지원하는 브라우저는 사파리 뿐이다.)



아래의 두개의 코드는 정확하게 같은 코드이다. 

이 코드가 같은지를 확인하고 패턴을 파악하는 훈련을 해야 한다.

```javascript
const add = (v, acc = 0) => v > 1 ? add(v-1, acc+v) : acc + 1;
add(100)
```

```javascript
const v = 100;
let acc = 0;
for(let i = 100; i > 1; i--){
    acc += i;
}
acc +=1;
```



꼬리재귀최적화는 인덱스 자체를 리턴해줘야 한다. 





## 노이만 머신



## 문과 값 

문 : 엔진이 실행 서술형. 

값 : 실행기를 밖에 둬야 한다. (실행기와 공급기의 쌍으로 이뤄짐). 대상화 시킨것



값 메모리에 할당하는 것으로서, 통제가 가능하고,

실행문은 실행이 종료됨과 동시에 휘발되어 버린다. 



## 지연실행

- 프로그램은 원래 처음부터 끝까지 쉬지 않고 실행된다. 
- 프로그램 실행 도중에, 실행을 미루거나 건너뛸 수 있도록 제어하는 모든 행위를 지연실행이라고 한다. 
- 런타임에 판단되므로,  Lazy라고 볼 수 있다. 





### 1) 호출지연

```javascript
function myFunc(){
    
}
```

- 함수를 호출 하는 것 : 노이만 머신의 흐름과 달리, myFunc는 실행문을 만나기전까지 실행하지 않는다.



### 2) 연산지연

```javascript
const a = b || c;
```

- b가 참이라면 c는 무시된다. 



### 3) 제어문 Flow Control Statement 을 이용한 지연







## Concurrency vs Parallelism

- Concurrency  : 흔히 동시성이라고 번역되지만, 정말 똑같은 시간에 동시에 일어나는 것을 뜻하지는 않는다.

  시분할 컴퓨팅에서 각 프로세스를 왔다리갔다리 하면서 마치 동시에 처리되는 것 같은 효과를 주는 것을 뜻한다.

- Parallelism : 병렬성 - 여러개의 프로세스가 한꺼번에 각자의 플로우 안에서 동시에 일어나는 것, 자바스크립트는 이 방식으로 움직인다.



## 제어 역전

- 제어 역전 : 
- 반 제어 역전 : 
