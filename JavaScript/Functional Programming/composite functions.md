# composite functions



## go

초기값과, 연속적으로 이어질 함수들을 입력받아, 하나의 값으로 귀결시키는 함수

```javascript
const go = (...args) => reduce((a,f) => f(a), args);

go(
    0, 
    a => a + 1,
    a => a + 10,
    a => a + 100,
    log
);
// 111
```

- reduce 를 사용한다. 
- 초기값과 함수들로 구성된 인자를 받아서, 루프를 돌며, 함수로 누적값을 갱신한다.



## pipe

함수 여러개를 입력받아, 하나의 함수로 합성해주는 함수

```javascript
const pipe = (...fs) => (a => go(a, ...fs));

const f = pipe(
    a => a + 2,
    a => a + 20,
    a => a + 200,
);

log(f(0)); //222
```

- go 를 사용한다.
- 함수를 리턴한다. 람다식에서 함수가 값이 실행대기라고 볼 수 있다면, pipe는 실행대기를 위한 대기 라고 볼수 있다.
- 여기서 일어나는 마법은, fs가 array 이며 well-formed iterable 이라는 것이다.
- 즉, pipe에 몇개의 값을 집어넣든 fs 는 이를 iterable로 처리할 수 있다는 뜻이다.



## curry

함수를 받아서 내가 원하는 시점에 호출하도록 하는 보조함수

```javascript
const curry = f =>
    (a, ..._) => _.length  // (a)
        ? f(a, ..._)  // (b)
        : (..._) => f(a, ..._); // (c)

const mult = curry((a, b) => a * b); // (d)

log(mult(3)); //(e)
log(mult(3)(2)); //(f)
```

#### 함수

커리는 f함수 하나를 받아서, '새 함수'를 리턴하는 함수인데,

- 이 새 함수는 
  - (a)  n 개의 인자를  a라는 값과 _라는 배열로 나누어 받은 다음, 
    - 인자가 두개 이상 있는지 (length가 0 이상인지) 검사를 하고,
      - (b) 두번째 인자가 있으면 즉시 함수를 실행하고 그 결과를 리턴
      - (c) 두번째 인자가 없으면 함수를 리턴
  - 해주는 함수이다.

#### 실행결과

- (e) 에서 아직 결과는 함수이다.
- (f) 에서 인자를 한번 더 받게되면 그제서야 값을 낸다.