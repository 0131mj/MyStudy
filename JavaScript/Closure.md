# Closure



## 클로저의 개념

```javascript
function outer(){
    var x = 0;
    return function(){
        return ++x;
    };
}

var x = -1;
var f = outer();
var g = outer();

console.log(f()); //1
console.log(f()); //2
console.log(f()); //3
console.log(g()); //1
console.log(g()); //2
console.log(g()); //3
```

x는 outer내부에도 정의되어 있고, 외부에도 정의되어 있다. 

변수 var f에 outer함수를 실행한 결과를 집어넣은 다음에 f를 실행해서 콘솔로 찍어보면 결과는 1이 된다. 그 이유는 return function 안에 있는 ++x의 x는 렉시컬 스코프의 원칙에 따라 정의된 영역에 있는 var x= 0을 참조하기 때문이다. 

여기서 중요한 것은 f();가 실행을 거듭할수록 내부변수 x의 값이 커진다는 사실인데, 그 이유는 x의 메모리를 삭제하기 못했기 때문이다. 갈 곳 없는 x는 자유변수라고 불리어지며, 언제 호출되든 메모리를 유지하고 있다. 이처럼 outer 호출이 종료되더라도 outer의 지역변수 및 변수 스코프객체의 체인 관계를 유지할 수 있는 구조를 클로저라고 한다.



## 클로저 인스턴스

다르게 말해 클로저란, 호출하면 다른 함수 인스턴스를 생성해내는 특수한 구조의 함수이다. 
이것은 마치 일반 객체지향 프로그래밍 언어에서 함수를 생성하는 클래스와 비슷하다고 볼 수 있다. 

위 코드에서 var g라는 변수에 다시 outer() 클로저를 담으면 내부변수 var x가 초기화된다. 여기서 알 수 있는 하나의 사실은, outer가  단순히 익명함수를 리턴하는 역할에 그치는 것이 아니라 익명함수를 둘러싼 공간을 함께 var g에 넘겨준다는 것이며 여기에는 outer클로저함수에 속한 내부 변수가 함께 포함되어 있다는 것이다.



## 클로저 작성시 제약사항

Function으로 생성한 함수는 클로저를 만들지 못한다. 그 이유는 Function 생성자를 이용해 생성한 함수는 렉시컬 영역을 사용하는 것이 아니라 전역에서 생성된 것처럼 컴파일 되기 때문이다. 